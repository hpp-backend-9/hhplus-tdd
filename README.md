# 포인트 관리 시스템

## 요구사항

- PATCH  `/point/{id}/charge` : 포인트를 충전한다.
- PATCH `/point/{id}/use` : 포인트를 사용한다.
- GET `/point/{id}` : 포인트를 조회한다.
- GET `/point/{id}/histories` : 포인트 내역을 조회한다.
- 잔고가 부족할 경우, 포인트 사용은 실패하여야 합니다.
- 동시에 여러 건의 포인트 충전, 이용 요청이 들어올 경우 순차적으로 처리되어야 합니다.

### `Step 1`

- 포인트 충전, 사용에 대한 정책 추가 (잔고 부족, 최대 잔고 등)
    - 동시에 여러 요청이 들어오더라도 순서대로 (혹은 한번에 하나의 요청씩만) 제어될 수 있도록 리팩토링
- 동시성 제어에 대한 통합 테스트 작성

### `Step 2`

- 동시성 제어 방식에 대한 분석 및 보고서 작성

---

## 동시성(Concurrency) 문제

여러 스레드가 동시에 동일한 자원에 접근하면 첫 번째 요청이 반영되기 전에 두 번째 요청이 먼저 반영되면서 데이터 불일치가 발생할 수 있습니다. 이로 인해 사용자의 잔여 포인트가 잘못 계산될 수 있습니다.<br>
해당 문제는 `다른` 사용자에 대한 요청이 아닌, `같은` 사용자에 대한 요청이 동시에 오는 경우에 제어가 필요합니다.

## 동시성 제어

해당 문제를 해결하기 위해 `ReentrantLock`을 이용한 동시성 제어 방식을 사용했습니다. <br>
ReentrantLock은 Java에서 제공하는 동시성 제어 도구로 **한 번에 하나의 스레드만** 접근하도록 보장합니다. 특히, **동일한 자원**에 대한 다중 접근을 제어해줍니다.<br>
또한 사용자별(ID별)로 Lock을 관리하여 여러 사용자가 동일한 자원에 접근하지 않도록 할 수 있으며, 스레드가 Lock을 획득할 때까지 대기한 후 하나의 작업이 완료된 이후에 다음 스레드가 작업을 할 수 있도록
하여 동시성 문제를 해결해줍니다.

```java
// 기본 구조
class TestClass {
    private ReentrantLock lock = new ReentrantLock(); // Lock 생성

    public testMethod() {
        lock.lock(); // Lock
        try {
            //임계 영역
        } finally {
            lock.unlock(); // Lock 해제
        }
    }
}
```

## 동시성 테스트

다음과 같은 동시성 시나리오를 주어 테스트를 진행했습니다.<br>

1. **포인트 충전 및 사용 요청이 동시에 들어오는 경우**
2. **잔여 포인트 보다 큰 금액 사용 요청이 들어오는 경우**

## 결론

- `ReentrantLock`을 사용한 동시성 제어는 데이터가 덮어쓰이는 현상을 방지하고 데이터 무결성을 보장합니다.
- 사용자별로 Lock을 두어 특정 사용자에 대한 다중 요청이 순차적으로 처리되도록 제어해줍니다.